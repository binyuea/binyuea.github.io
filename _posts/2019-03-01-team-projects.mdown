---
layout:     post
title:      Team Projects
author:     Haibin
tags:		kafka microservice tungsten
subtitle:  	some team projects which I am the main code contributor
category:  projects
---
## Start
These are team projects of my company, so I cannot provide too much detail data. But feel free to discuss the design and implementation.

### Tenant Filter
1. The Tenant Filter is to filter out disabled tenants from source side -- tungsten(db replicator).  
2. The result is great: with this feature, the latency has been decreased from several minutes to under 1s.
3. The idea is from my manager, I just implement his idea.
##### Results
I deployed this feature at 11:00 PM, Feb 22. You can see there is a huge drop down on `records-poll-rate`. Because we filter out many disabled tenants events, there is no need to wait for the long call-back, the event handling latency has been decreased obviously.
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter1.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br>
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter2.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br>
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter3.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br>

##### key word:
1. cache.refresh(non-blocking).
<a href="https://github.com/google/guava/wiki/CachesExplained">guava cache</a> 
2. cache size: only one key. That is a `final static String name`, which points to a `Set<String> activeTenants`.
<a href="https://github.com/google/guava/issues/872">One key may be faster here.</a>

### TopicMessage API
An API can GET/POST record from/to a specific position(topic, partition, offset) in Kafka.
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/topic_message_api.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>

#### Some trade-off
To implement this feature, we need to serializer/deserializer record to/from kafka. And different topic has different Serializer/Deserializer.  
So there are several ways to handle this problem. Trade-off.
- TOPIC Mapping:
mapping includes two parts:

1. Logic topic name (user input) to physical topic name(topic name in kafka).          e.g. For Notification service, the topic name in kafka is "NotificationV2", and we also have related topic name like "NotificationForDC" in kafka.
2. Topic name to Kafka record deserializer.          e.g. we have "NotificationInstanceDeserializer" for Notification. It's needed for API to decode record.
Current Design difference:

- Details
For the second problem, we do have some trade-off:
*Topic name to Kafka record deserializer*
1. no mapping: not doable
2. 1-to-1 mapping: like "NotificationV2" -> "NotificationInstanceDeserializer" and "NotificationForDC" -> "NotificationInstanceDeserializer" are different entries in mapping.
    - Pros: 
        1. easy to implement.
        2. support Logic topic name to physical one. DIY
        3. restrict user input.
    - Cons:
        1. need to maintain this mapping every time topic or deserializer updates.    like we have "NotificationForDC" and then we have "RepartitionedNotificationForDC", we need to update the transformer accordingly if we want to support all these topics.
        2. need to initial mapping entries as many as topics we want to support.
3. many-to-1 mapping: like "NotificationV2" and "NotificationForDC" are considered "Notification" service, therefore handled with "NotificationInstanceDeserializer".
    - Pros:
        1. no need to maintain it when new topics created or topic name modified.
        2. easy to understand. 
        3. clean code.
    - Cons:
        1. cannot handle confusing topic names. Like "BussinessEventNotification". 
        2. still support for some deprecated topics. Like "Notification".
4. service-to-deserializer mapping: i.e. Users need to specify which service their topic belongs to. In this way, users need to provide 4 parameters: service, topic, partition and offset.
    - Pros:
        1. Pros of "many-to-1" mapping
        2. can handle confused topic names.
        3. reasonable and safe: when POST, users should know which service they want to do POST, to change the record data.
    - Cons:
        1. more parameter for users to input.
 

