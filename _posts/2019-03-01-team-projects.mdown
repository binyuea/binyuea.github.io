---
layout:     post
title:      Team Projects
author:     Haibin
tags:		kafka microservice tungsten
subtitle:  	some team projects which I am the main code contributor
category:  projects
---
## Start
These are team projects of my company, so I cannot provide too much detail data. But feel free to discuss the design and implementation.

## Tenant Filter
1. The Tenant Filter is to filter out disabled tenants from source side ---- tungsten(db replicator).  
2. The result is great: with this feature and some other filters, the following pipeline latency has been decreased from several minutes to under 1s.
3. The idea is from my manager, I just implement his idea.  
### key word:
1. cache.refresh(non-blocking).  
<a href="https://github.com/google/guava/wiki/CachesExplained" style="color: rgb(0,102,204)">Guava cache</a> 
2. cache size: only one key. That is a `final static String name`, which points to a `Set<String> activeTenants`.  
<a href="https://github.com/google/guava/issues/872" style="color: rgb(0,102,204)">Only one key in the cache may be faster here.</a>
### Results
I deployed this feature to production at 11:00 PM, Feb 22. You can see there is a huge drop down on `records-poll-rate`. There are multiple patches in this deployment, so tenant filtering would be one of the reasons. (Hold the picture to zoom in) 
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter1.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br> Because we filter out many disabled tenants events, there is no need to wait for the long call-back, the event handling latency has been decreased obviously. (Hold the picture to zoom in)
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter2.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br> Now the avg lantency is under 1 second, so the performance has been improved by 10x. Even my manager was impressed by it.
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/tenant_filter3.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>
<br>



## TopicMessage API
An API can GET/POST record from/to a specific position(topic, partition, offset) in Kafka.
<div style="text-align:center"><img src= "{{ "/img/projects/team_projects/topic_message_api.png" | prepend: site.baseurl }}" style="width: 100%; margin-left: 0%; margin-right: 0%;"></div>

### Some trade-off
To implement this feature, we need to Serializer/Deserializer record to/from kafka. And different topic has different Serializer/Deserializer.  
So there are several ways to handle this problem. Trade-off.
- TOPIC Mapping:  
1. Logic topic name (user input) -> physical topic name(topic name in kafka).  
e.g. For Notification service, the topic name in kafka is "NotificationV2", and we also have related topic name like "NotificationForDC" in kafka.
2. Topic name -> Kafka record deserializer.  
e.g. we have "NotificationInstanceDeserializer" for Notification. It's needed for API to decode record.  

#### Details  
For the second problem, we do have some trade-off:  
*Topic name to Kafka record deserializer*
- *no mapping*: not doable
- *1-to-1 mapping*: like "NotificationV2" -> "NotificationInstanceDeserializer" and "NotificationForDC" -> "NotificationInstanceDeserializer" are different entries in mapping.
    - Pros: 
        - easy to implement.  
        - support Logic topic name to physical one. DIY  
        - restrict user input.  
    - Cons:
        - need to maintain this mapping every time topic or deserializer updates.  
        like we have "NotificationForDC" and then we have "RepartitionedNotificationForDC", we need to update the transformer accordingly if we want to support all these topics.   
        - need to initial mapping entries as many as topics we want to support.   
- *many-to-1 mapping*: like "NotificationV2" and "NotificationForDC" are considered "Notification" service, therefore handled with "NotificationInstanceDeserializer".  
    - Pros:
        - no need to maintain it when new topics created or topic name modified.  
        - easy to understand.   
        - clean code.  
    - Cons:
        - cannot handle confusing topic names. Like "BussinessEventNotification".   
        - still support for some deprecated topics. Like "Notification".  
- *service-to-deserializer mapping*: i.e. Users need to specify which service their topic belongs to. In this way, users need to provide 4 parameters: service, topic, partition and offset.  
    - Pros:  
        - Pros of "many-to-1" mapping  
        - can handle confused topic names.  
        - reasonable and safe: when POST, users should know which service they want to do POST, to change the record data.  
    - Cons:  
        - more parameters for users to input.  

 

